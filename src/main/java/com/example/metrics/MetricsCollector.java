package com.example.metrics;

import io.micrometer.core.instrument.*;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

public class MetricsCollector {
    
    private static final Logger logger = LoggerFactory.getLogger(MetricsCollector.class);
    
    private final MeterRegistry meterRegistry;
    
    private final Counter recordsGenerated;
    private final Counter recordsProcessed;
    private final Counter errors;
    private final Timer batchProcessingTime;
    private final Gauge currentBatchSize;
    private final Timer consumerProcessingTime;
    private final Counter duplicatesSkipped;
    
    private final AtomicLong currentBatchSizeValue = new AtomicLong(0);
    private final AtomicReference<Double> lastProcessingTimeSeconds = new AtomicReference<>(0.0);
    
    public MetricsCollector() {
        this.meterRegistry = new SimpleMeterRegistry();
        
        this.recordsGenerated = Counter.builder("elastic.producer.records.generated")
            .description("Total number of records generated by producer")
            .register(meterRegistry);
            
        this.recordsProcessed = Counter.builder("elastic.consumer.records.processed")
            .description("Total number of records processed by consumer")
            .register(meterRegistry);
            
        this.errors = Counter.builder("elastic.errors.total")
            .description("Total number of errors")
            .register(meterRegistry);
            
        this.batchProcessingTime = Timer.builder("elastic.producer.batch.processing.time")
            .description("Time taken to process a batch")
            .register(meterRegistry);
            
        this.currentBatchSize = Gauge.builder("elastic.producer.batch.current.size", currentBatchSizeValue, AtomicLong::doubleValue)
            .description("Current batch size in producer")
            .register(meterRegistry);
            
        this.consumerProcessingTime = Timer.builder("elastic.consumer.processing.time")
            .description("Time taken by consumer to process records")
            .register(meterRegistry);
            
        this.duplicatesSkipped = Counter.builder("elastic.consumer.duplicates.skipped")
            .description("Total number of duplicate records skipped")
            .register(meterRegistry);
    }
    
    public void incrementRecordsGenerated() {
        recordsGenerated.increment();
    }
    
    public void incrementRecordsProcessed() {
        recordsProcessed.increment();
    }
    
    public void incrementRecordsProcessed(long count) {
        recordsProcessed.increment(count);
    }
    
    public void incrementErrors() {
        errors.increment();
    }
    
    public void incrementDuplicatesSkipped() {
        duplicatesSkipped.increment();
    }
    
    public void incrementDuplicatesSkipped(long count) {
        duplicatesSkipped.increment(count);
    }
    
    public void recordBatchProcessed(int batchSize, long durationMs) {
        batchProcessingTime.record(durationMs, java.util.concurrent.TimeUnit.MILLISECONDS);
    }
    
    public void recordConsumerProcessingTime(long durationMs) {
        consumerProcessingTime.record(durationMs, java.util.concurrent.TimeUnit.MILLISECONDS);
        lastProcessingTimeSeconds.set(durationMs / 1000.0);
    }
    
    public void updateCurrentBatchSize(long size) {
        currentBatchSizeValue.set(size);
    }
    
    private double getCurrentBatchSizeValue() {
        return currentBatchSizeValue.get();
    }
    
    public void printMetrics() {
        if (logger.isInfoEnabled()) {
            logger.info("=== Metrics Summary ===");
            logger.info("Records Generated: {}", recordsGenerated.count());
            logger.info("Records Processed: {}", recordsProcessed.count());
            logger.info("Errors: {}", errors.count());
            logger.info("Duplicates Skipped: {}", duplicatesSkipped.count());
            logger.info("Current Batch Size: {}", currentBatchSizeValue.get());
            logger.info("Last Processing Time: {} seconds", lastProcessingTimeSeconds.get());
            logger.info("Average Batch Processing Time: {} ms", 
                       batchProcessingTime.mean(java.util.concurrent.TimeUnit.MILLISECONDS));
            logger.info("Average Consumer Processing Time: {} ms", 
                       consumerProcessingTime.mean(java.util.concurrent.TimeUnit.MILLISECONDS));
            logger.info("=======================");
        }
    }
    
    public MeterRegistry getMeterRegistry() {
        return meterRegistry;
    }
    
    public double getRecordsGenerated() {
        return recordsGenerated.count();
    }
    
    public double getRecordsProcessed() {
        return recordsProcessed.count();
    }
    
    public double getErrors() {
        return errors.count();
    }
    
    public double getDuplicatesSkipped() {
        return duplicatesSkipped.count();
    }
    
    public double getAverageBatchProcessingTime() {
        return batchProcessingTime.mean(java.util.concurrent.TimeUnit.MILLISECONDS);
    }
    
    public double getAverageConsumerProcessingTime() {
        return consumerProcessingTime.mean(java.util.concurrent.TimeUnit.MILLISECONDS);
    }
}